<!DOCTYPE html>
<html>
    <head>
        <title>Journal | Vertiefungsthema</title>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1">
        <link rel="icon" href="../img/favicon.ico"  type="image/icon type">
        <link rel="stylesheet" href="../css/style.css">
        <script src="../js/site.js"></script>
        <link rel="stylesheet" href="../css/vs2015.min.css">
        <script src="../js/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>
    <body>
        <button onclick="topFunction()" id="goToTopButton" title="Go to top">Top</button>
        <div id="contentWrapper">
            <a id="goBack" href="index.html"><img src="../img/icons/left-arrow.svg"/></a>
            <header>
                <h1>Web-Programmierung</h1>
            </header>
            <section id="breadcrumbs">
                <p><a href="../index.html">Home</a> > <a href="index.html">Web-Programmierung</a> > Vertiefungsthema</p>
            </section>
            <main id="blog">
                <section>
                    <header>
                        <h2>Vertiefungsthema</h2>
                        <!--<p><img class="calenderIcon" src="../img/icons/calender.png"/> 30.11.2020</p>-->
                    </header>
                    <main>
                        <p>
                            Nun gut... ich soll ein Thema w√§hlen, welches ich vertiefen m√∂chte. Au√üerdem soll es einen Bezug zum Thema "Web-Programmierung" haben... verst√§ndlich. Aber was nimmt man 
                            da am Besten. Die Auswahl ist ja nicht gerade klein.<br>
                            Diese Frage hat mich nun eine Weile besch√§ftigt und ich kam zu dem Schluss, dass ich mir etwas anschauen m√∂chte, dass mich schon l√§nger interessiert.
                        </p>
                        <p>
                            Und dieses omin√∂se Thema ist...
                        </p>
                        <img style="width: 40%; margin: 0 30% 0;" src="vertiefungsThema/drumroll.gif">
                        <img src="vertiefungsThema/react.PNG">
                        <p>
                            Ja genau, wir schauen uns React an. Denn warum sollte man denn etwas Einfaches zum Erkl√§ren nehmen, wenn man auch einfach versuchen kann ein weiteres Framework zu erkl√§ren. 
                            Und ja, React ist eine Bibliothek/ein Framework. Und ein/-e komplizierte/-s noch dazu. An dieser Stelle lasse ich auch das Wort Framework fallen und verwende von nun an nur noch 
                            das Wort Bibliothek (wird sonst zu aufwendig).
                        </p>
                        <h2>Was bitte ist React und was macht das?</h2>
                        <p>
                            Die <a href="https://reactjs.org/" target="_blank">React Website</a> selbst beschreibt React als eine JavaScript Bibliothek zum Erstellen von komplexen User Interfaces. Es bietet aber noch viel mehr als das. So lassen sich komplette Web Anwendungen 
                            darin schreiben und Websites in einzelne, isolierte und wiederverwendbare "Komponenten" unterteilen.
                        </p>
                        <pre>
                            <code class="JavaScript">
    class ShoppingList extends React.Component {
        render() {
            return (
            &lt;div className="shopping-list">
                &lt;h1>Shopping List for {this.props.name}&lt;/h1>
                &lt;ul>
                    &lt;li>Instagram&lt;/li>
                    &lt;li>WhatsApp&lt;/li>
                    &lt;li>Oculus&lt;/li>
                &lt;/ul>
            &lt;/div>
            );
        }
    }
        
    // Example usage: &lt;ShoppingList name="Mark" />
                            </code>
                        </pre>
                        <p>
                            Hier sieht man ein Beispiel einer solchen Komponente ShoppingList. Diese ist in hier eine Subklasse von React.Component, aber es gibt noch andere.
                        </p>
                        <h2>Wie genau wird dieses Thema pr√§sentiert?</h2>
                        <p>
                            Ich habe mir bis jetzt schonmal verschiedene Videos zum Thema angeschaut und auch ein Wenig in der Dokumentation von React selbst gelesen. Dabei kam ich zum Schluss, dass es wohl im Rahmen 
                            dieser Vertiefung am Besten w√§re etwas Praktisches zu machen. Hier bietet sich das offizielle Tutorial von React geradezu an und so werde ich im Laufe dieser Vertiefung eben jenes durcharbeiten und meine Erkenntnisse 
                            mit dir/Ihnen (je nachdem wer das hier liest) teilen.<br>
                            So habe ich mehr Spa√ü, ich kann mehr mit Bildern und Videos Arbeiten (d.h. es wird weniger langweiliger Flie√ütext) und am Ende kommt sogar etwas Interaktives dabei raus. Was genau das wird, dazu sp√§ter mehr.
                        </p>
                        <h2>Wie entwickelt man nun React Apps?</h2>
                        <p>
                            React Apps sind im Vergleich zu JQuery basierten Webanwendungen ein Wenig komplizierter aufzusetzen. So gen√ºgt es nicht einfach eine JavaScript Datei einzubinden und loszulegen, man muss ein Projekt bauen. Gl√ºcklicherweise √ºbernimmt 
                            letzeres zu gro√üen Teilen Node.js (eine JavaScript Runtime).<br>
                            Aber genug von der Theorie, los geht's mit der Praxis...
                        </p>
                        <h2>Das Projekt</h2>
                            <h3>Was entwickeln wir?</h3>
                            <p>
                                Wie bereits erw√§hnt, hangeln wir uns am offiziellen React Tutorial entlang und so entwickeln wir...
                            </p>
                            <p>
                                Tic-Tac-Toe
                            </p>
                            <p>
                                Nicht das spannendste Spiel der Welt, aber immerhin ein Spiel üòÅ.
                            </p>
                            <h3>Setup</h3>
                            <p>
                                Unter der Vorraussetzung, dass wir Node.js installiert haben (das habe ich nat√ºrlich schon im Vorhinein erledigt) k√∂nnen wir auch schon direkt loslegen. 
                                Ich nutze Visual Studio Code (kurz: VS Code) f√ºr den gesammten Entwicklungsprozess, da es a) mittlerweile so ziemlich die beste kostenlose Entwicklungsumgebung ist und ich b) ohnehin schon damit arbeite. Selbst dieser Text wird gerade 
                                darin geschrieben.
                            </p>
                            <p>
                                Wir erstellen also einen neuen Ordner auf unserer Festplatte (bei mir der unglaublich kreative Name "reactTutorial"), √∂ffnen VS Code, √∂ffnen den Ordner darin und √∂ffnen das Terminal (auf Windows mit strg+shift+√∂). Dort schreiben wir <i>"npx create-react-app reacttutorial"</i>. Darufhin beginnt Node.js mit 
                                der Erstellung unseres Projektes. Das kann einige Zeit dauern also mache ich mir jetzt mal einen Tee.
                            </p>
                            <p>
                                Das Projekt wirde nun erfolgreich erstellt und wir finden die links im Bild gezeigte Ordnerstruktur vor. Wir l√∂schen die Beispieldateien im <i>src</i> Ordner und ersetzen diese durch unsere eigene <i>index.css</i> f√ºr unsere Styles und durch eine <i>index.js</i> f√ºr unseren 
                                JavaScript Code. Das orangene M neben den neu erstellten Dateien bedeutet im √ºbrigen, dass die von React standardm√§√üig vorkonfiguerte Git Versionskontrolle funktioniert. VS Code erkennt diese automatisch und trackt √Ñnderungen.
                            </p>
                            <img src="vertiefungsThema/ordnerstruktur.PNG">
                            <p>
                                In unsere <i>index.js</i> schreiben wir nun das folgende:
                            </p>
                            <pre>
                                <code class="JavaScript">
    import React from 'react';
    import ReactDOM from 'react-dom';
    import './index.css';
                                </code>
                            </pre>
                            <p>
                                Dieser Code importiert nun drei wichtige Abh√§ngigkeiten. Die f√ºr React wichtigen sowie unserer gerade erst erstellten index.css. Au√üerdem kopieren wir dort hinein den JavaScript Teil des uns von React gegebenen <a href="https://codepen.io/gaearon/pen/oWWQNa" target="_blank">"Starter Codes" (hier klicken f√ºr den CodePen Link</a>. 
                                Dieser beinhaltet aber nicht nur JavaScript Komponenten. Er beinhaltet auch einen vorgefertigten CSS Code und einen vorgefertigten HTML Code, sodass wir am Ende ein Tic-Tac-Toe Gitter erhalten.<br>
                                Anbei, der HTML Code muss in die von uns bis jetzt noch nicht anger√ºhrte index.html im Ordner public. Diese Datei ist die, die von au√üen her erreichbar ist (wie der Ordner Name public bereits suggeriert). Weil es aber schwierig ist, denn kompletten Inhalt der einzelnen Dateien hier auf die Seite zu packen fasse ich ihn kurz zusammen (allerdings kann man sich den Code auf CodePen [siehe Link weiter oben] anschauen).
                            </p>
                            <ul>
                                <li><b>src/index.js</b>: Unsere Ausgangsdatei f√ºr React. Der Starter Code enth√§lt bereits die drei Klassen Game, Board (also das Spielbrett) und Square (also ein einzelnes Quadrat). Die Zugriffsreihenfolge sollte relativ selbsterkl√§rend sein. So "erstellt" das Game ein Board und das Board "erstellt" 9 Squares. Zur√ºckgegeben wird anschlie√üend ein komplettes Tic-Tac-Toe Feld mit Hilfe der <i>render</i> Methoden der Klassen.</li>
                                <li><b>src/index.css</b>: Diese Datei ist f√ºr das Styling zust√§ndig und sorgt hier daf√ºr, dass unser Spielbrett auch wie eines aussieht und nicht wie 9 wahrlos umhergeschmissene Buttons.</li>
                                <li><b>public/index.html</b>: Diese Datei ist der √∂ffentliche index und erh√§lt durch den Starter Code einen <i>div</i>-Container f√ºr Fehlermeldungen, einen <i>div</i>-Container mit der ID root (der Ausgangspunkt f√ºr React) und einen <i>script</i>-Tag mit ein paar Event Listenern welche die Eingaben des Users erfassen und uns erm√∂glichen darauf zu reagieren.</i></li>
                            </ul>
                            <p>
                                Nachdem wir nun den "Starter Code" erfolgreich in unser Projekt √ºbernommen haben k√∂nnen wir mit <i>"npm start"</i> √ºber das Terminal den Node.js Developement Server starten. Dieser √∂ffnet dann unseren Standardbrowser und wir erhalten das folgende Bild:
                            </p>
                            <img src="vertiefungsThema/leeresSpielfeld.PNG">
                            <p>
                                Damit ist unser initiales Setup abgeschlossen und wir k√∂nnen nun mit dem eingentlichen Tutorial beginnen.
                            </p>
                            <!-- Los gehts -->
                            <h3>Erste Erfahrungen mit props</h3>
                            <p>
                                Nun da wir unser Projekt "eingerichtet" haben k√∂nnen wir beginnen damit zu experimentieren. Wir beginnen mit dem Manipulieren von sogenannten props oder auch properties. Dies sind Eigenschaften, die wir in React mit Hilfe von JSX an andere Komponenten √ºbergeben k√∂nnen. √Ñhnlich wie Parameter bei Methoden.<br>
                                "Aber Moment mal... was ist JSX?" wird sich der ein oder andere fragen. Nun JSX steht f√ºr JavaScript Systax Extension und ist eine Erweiterung der √ºblichen JavaScript Grammatik f√ºr React. Genutzt wird daf√ºr XML was daf√ºr sorgt, dass der Code auch gewisse √Ñhnlichkeiten mit HTML aufweist. In gewisser Hinsicht wird hier 
                                der Spie√ü umgedreht. "Normalerweise" wird ja JavaScript in HTML eingebaut. Nun wird HTML in JavaScript eingebaut.
                            </p>
                            <p>
                                Um die Funktionsweise von Props nun zu veranschaulichen bauen wir unseren Code wie folgt um. Wir √§ndern die <i>renderSquare</i>-Methode der <i>Board</i>-Klasse und f√ºgen ihr einen prop mit dem Namen "value" hinzu. Dieser √ºbergibt den aktuellen Index eines Squares.
                            </p>
                            <pre>
                                <code class="JavaScript">
    class Board extends React.Component {
        renderSquare(i) {
            return &lt;Square value={i} />;
        }
    }
                                </code>
                            </pre>
                            <p>
                                In der <i>Square</i>-Klasse widerrum nutzen wir nun dieses Value und zeigen es auf dem Button an.
                            </p>
                            <pre>
                                <code class="JavaScript">
    class Square extends React.Component {
        render() {
            return (
            &lt;button className="square">
                {this.props.value}
            &lt;/button>
            );
        }
    }
                                </code>
                            </pre>
                            <p>
                                Unsere Squares sind somit nicht mehr leer, sonder zeigen ihren jeweiligen Index an. Das Endresultat sieht dann so aus:
                            </p>
                            <img src="vertiefungsThema/zahlenSpielfeld.PNG">
                            <p>
                                Wir haben also erfolgreich ein Prop von einem Eltern Element zu einem Kind Element weitergegeben. In React werden so Informationen verteilt.
                            </p>
                            <h3>Interaktive Buttons</h3>
                            <p>
                                Jetzt k√∂nnen wir also Zahlen ausgeben. Super spannend...üôÑ<br>
                                Wir wollen nun auch etwas anklicken k√∂nnen also beginnen wir doch mal damit, dass ein Square ein "X" erh√§lt wenn wir es anklicken. Dazu f√ºgen wir dem <i>button</i> in der <i>Square</i>-Klasse 
                                erst mal einen OnClick Event Handler hinzu.
                            </p>
                            <pre>
                                <code class="JavaScript">
    class Square extends React.Component {
        render() {
            return (
            &lt;button className="square" onClick={() => alert('click')}>
                {this.props.value}
            &lt;/button>
            );
        }
        }
                                </code>
                            </pre>
                            <p>
                                Aber Moment mal, was macht der Pfeil da drin und wo ist unsere anonyme function? Nun um das kurz aufzukl√§ren, hierbei handelt es sich um sogenannte "Arrow-Functions". Eingef√ºhrt wurden sie mit ES6 im Jahr 2015. 
                                Diese gab es bereits davor schon in anderen Sprachen (wie beispielsweise C# - daher kenne ich sie). Es handelt sich hier um einen vereinfachten Syntax zum Schreiben von Funktionen. Aufgebaut sind sie dabei immer nach dem gleichen Schema. 
                                Erst kommt eine runde Klammer welche die Parameter enth√§lt, dann ein => und dann eine geschweifte Klammer, welche den Funktionscode enth√§lt. Alternativ kann man diese auch benennen indem man ein <i>let funktionsName =</i> davor schreibt.
                                Wen dieses Thema noch weiter interessiert, dem w√ºrde ich das <a href="https://www.youtube.com/watch?v=h33Srr5J9nY&ab_channel=WebDevSimplified">Video von Web Dev Simplified</a> empfehlen.
                            </p>
                            <pre>
                                <code class="JavaScript">
    // Beispiel mit Name
    let addieren = (a,b) => {
        return a+b
    };
    // Bei simplen Functions kann man die geschweiften Klammen und return auch weglassen
    let addierenEinfach = (a,b) => a+b;
                                </code>
                            </pre>
                            <p>
                                Aber genug dazu, zur√ºck zum eigentlichen Code. Wir k√∂nnen nun die Squares anklicken und ein <i>alert</i>-Fenster informiert uns dar√ºber, dass das erfolgreich war. Wie aber speichern wir diesen Klick?<br>
                                Die Antwort ist im <i>state</i> der Komponente, einer privaten Variable des Squares. Um diese nun zu setzen muss die Komponente erst einmal eine besitzen. Wir f√ºgen also erst einmal einen Konstruktor hinzu der diese Variable f√ºr uns deklariert und initialisiert.
                            </p>
                            <pre>
                                <code class="JavaScript">
    class Square extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
            value: null,
            };
        }
    // ...
                                </code>
                            </pre>
                            <p>
                                Der <i>super(props)</i> Aufruf meint hier den Konstruktor der Superklasse (hier React.Component). Er muss immer zu erst aufgerufen werden. Danach definieren wir unseren State in JSON. Zu Beginn ist sein Wert null.
                                Abschlie√üend m√ºssen wir nur daf√ºr sorgen, dass ein Klick auf ein Square den State √§ndert und dieser dann auch angezeigt wird. Dazu gehen wir in die <i>render</i>-Methode zut√ºck und passen diese folgenderma√üen an:
                            </p>
                            <pre>
                                <code class="JavaScript">
    class Square extends React.Component {
        constructor(props){
            super(props);
            this.state = {
                value: null,
            };
        }
    
        render() {
            return (
            // OnClick setzt nun den State
            // Der State wird anschlie√üend ausgegeben
            &lt;button className="square" onClick={() => this.setState({value: 'X'})}>
                {this.state.value}
            &lt;/button>
            );
        }
    }
                                </code>
                            </pre>
                            <p>
                                Das Ergebnis kann sich schon sehen lassen:
                            </p>
                            <video controls="controls">
                                <source src="vertiefungsThema/clickingXs.mp4" type="video/mp4">
                                Ihr Browser unterst√ºtzt den HTML Video Tag nicht.
                            </video>
                            <p>
                                So cool das jetzt schon ist, so schnell muss die Euphorie auch schon wieder weichen. Denn unser Ziel ist ja nicht eine "Zeichenfl√§che" f√ºr Xe sondern ein Tic-Tac-Toe Spiel. Also weiter im Text.
                            </p>
                            <h3>Den Spielstatus zwischenspeichern</h3>
                            <p>
                                Wir wollen jetzt also den aktuellen Status des Spielbrettes irgendwo zwischenspeichern. Dabei haben wir gerade noch ein Problem. Und zwar speichert aktuell jedes Square seinen eigenen Status. 
                                Das ist zwar naheliegend, aber nicht wirklich hilfreich wenn wir darauf sp√§ter weitere Logik aufsetzen lassen wollen. Eine L√∂sung w√§re nun, den Status des Brettes in der Board Klasse zu speichern 
                                und diesen durch die Squares updaten zu lassen. Daraufhin w√ºrde dann das Board das Square neu rendern.
                            </p>
                            <p>
                                Wir beginnen nun mit dem Konstruktor des Boards. Wir m√ºssen uns bei Erstelleung des Boards ein Array mit 9 Pl√§tzen erzeugen lassen, dass die Stati speichern kann. Dieses f√ºllen wir anfangs mit nulls.
                            </p>
                            <pre>
                                <code class="JavaScript">
    class Board extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
            squares: Array(9).fill(null),
        };
    }
    // ...
                                </code>
                            </pre>
                            <p>
                                Das Array mit 9 Pl√§tzen kann man sich sp√§ter wie ein "ausgerolltes" 3x3 Feld vorstellen.<br>
                                Als n√§chstes m√ºssen wir daf√ºr sorgen, dass das Square auch wei√ü welchen Status es hat. Wir m√ºssen also bei der Erstellung des Squares den Status mit √ºbergeben. 
                                Das machen wir in der render Methode des Boards (das i ist der index des Squares -> 0 bis 8).
                            </p>
                            <pre>
                                <code class="JavaScript">
    renderSquare(i) {
        return &lt;Square value={this.state.squares[i]} />;
    }
                                </code>
                            </pre>
                            <p>
                                Jetzt bekommt also jedes Square entweder ein "X", ein "O" oder null (f√ºr leere Felder). Eine Sache fehlt allerdings noch. Unser Square wei√ü jetzt zwar welchen Status es hat, kann daran aber nichts √§ndern.<br>
                                Jetzt wird es tricky. Der State des Boards ist privat, weswegen wir vom Square aus keinen Zugriff darauf haben. Auch eine Vererbungsstruktur √† la Java mit der Eigenschaft protected l√§sst sich nicht umsetzen.
                                Wir √ºbergeben nun deshalb dem Square neben dem Value noch eine Referenz auf eine Funktion handleClick der Board Klasse √ºber den onClick Event Handler. So kann das Square diese ausf√ºhren und das Board √§ndert den State.
                            </p>
                            <pre>
                                <code class="JavaScript">
    // renderSqare Methode des Boards
    renderSquare(i) {
        return (
            &lt;Square
            value={this.state.squares[i]}
            onClick={() => this.handleClick(i)} // Hier √ºbergeben wir die Referenz 
            />
        );
    }
                                </code>
                            </pre>
                            <p>
                                Innerhalb der Square Klasse m√ºssen wir dann nur daf√ºr sorgen, dass der √ºbergebene Wert angezeigt und der Event Handler an den Button weitergegeben wird.
                            </p>
                            <pre>
                                <code class="JavaScript">
    class Square extends React.Component {
        render() {
            return (
            &lt;button
                className="square"
                onClick={() => this.props.onClick()}
            >
                {this.props.value}
            &lt,/button>
            );
        }
    }
                                </code>
                            </pre>
                            <p>
                                Nachdem wir das alles gemacht haben k√∂nnen wir ja schonmal draufklicken oder? ... Nein.
                            </p>
                            <video controls="controls">
                                <source src="vertiefungsThema/clickHandleError.mp4" type="video/mp4">
                                Ihr Browser unterst√ºtzt den HTML Video Tag nicht.
                            </video>
                            <p>
                                Einen wichtigen Schritt haben wir noch nicht erledigt. Wir m√ºssen die handleClick Funktion noch anlegen. Diese sieht folgenderma√üen aus:
                            </p>
                            <pre>
                                <code class="JavaScript">
    handleClick(i) {
        const squares = this.state.squares.slice();
        squares[i] = 'X';
        this.setState({squares: squares});
    }
                                </code>
                            </pre>
                            <p>
                                Diese Funktion erstellt eine Kopie (mit der Slice Methode) des aktuellen Board Status, √§ndert das gew√ºnschte Square zu einem X und setzt den State mit dem modifizierten Status neu.
                            </p>
                            <p>
                                "Aber Moment mal, warum √§ndern wir nicht einfach den Status direkt sondern legen eine Kopie an?" fragt man sich bestimmt hier. Die Antwort ist relativ simpel. Wenn man die Objekte, die man √§ndern 
                                will mit einem direkten Zugriff √§ndert ist das einerseits un√ºbersichtlicher. Andererseits ist es auch schwerer √Ñnderungen zu erkennen, da man nicht ermitteln kann wie das Objekt vorher aussah. 
                                Ein weiterer Grund (im Kontext dieses Tutorials) ist auch, dass wir sp√§ter noch ein weiteres Feature einbauen. Und zwar werden wir sp√§ter zu vorherigen Z√ºgen zur√ºckspringen k√∂nnen. Dabei hilft uns diese 
                                Herangehensweise.
                            </p>
                            <h3>Funktions Komponenten</h3>
                            <p>
                                Zur Zeit haben wir drei Klassen: Game, Board und Square. Allerdings macht unser Square nicht vielmehr als das Ausgeben von HTML unter Einbeziehung von props. Es besitzt keinen eigenen State. Wir k√∂nnen daf√ºr 
                                nun ein Funktions Komponente nehmen. Sie erbt nicht von React.Component, sondern besitzt nur eine return Methode. Das sieht dann folgenderma√üen aus.
                            </p>
                            <pre>
                                <code class="JavaScript">
    function Square(props) {
        return (
            &lt;button className="square" onClick={props.onClick}>
            {props.value}
            &lt;/button>
        );
    }
                                </code>
                            </pre>
                            <p>
                                Neben der Platzerspaarnis, ist die Funktion auch nicht mehr so kompliziert zu nutzen wie die Klasse. So f√§llt das this. √ºberall weg und auch das onClick Event ist simpler geworden.
                            </p>
                            <h3>Verschiedene "Spieler"</h3>
                            <p>
                                Jetzt geht es aber endlich los mit etwas Spannenderem: Abwechselndes Spielen. Zur Zeit kann man nur Xe setzen. Es wird Zeit f√ºr Os. Um das zu verwirklichen brauchen wir zwei Dinge:
                            </p>
                            <ol>
                                <li>Die M√∂glichkeit zu tracken wer dran ist und</li>
                                <li>die M√∂glichkeit die Z√ºge entsprechend einzutragen.</li>
                            </ol>
                            <p>
                                Ersteres l√§sst sich einfach bewerkstelligen. Wir f√ºgen unserem Board State √ºber den Konstruktor einfach eine Varaiable xIsNext hinzu um festzustellen wer dran ist.
                            </p>
                            <pre>
                                <code class="JavaScript">
    class Board extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                squares: Array(9).fill(null),
                xIsNext: true,
            };
        }
                                </code>
                            </pre>
                            <p>
                                Daraufhin m√ºssen wir in der Handle Click Methode ber√ºcksichtigen wer dran ist, wenn ein Klick registriert wird. das tun wir hier mit einem Bedingungsoperator, der den Statuswert des 
                                Squares abh√§ngig von der Variable xIsNext setzt. Anschlie√üend wird die Variable beim Status setzen negiert.
                            </p>
                            <pre>
                                <code class="JavaScript">
    handleClick(i) {
        const squares = this.state.squares.slice();
        squares[i] = this.state.xIsNext ? 'X' : 'O';
        this.setState({
            squares: squares,
            xIsNext: !this.state.xIsNext,
        });
    }
                                </code>
                            </pre>
                            <p>
                                Ob das funktioniert sehen wir gleich. Davor w√ºrde ich gerne noch angezeigt bekommen, wer als n√§chstes dran ist. Dazu bearbeiten wir die die render Methode des Boards. In dieser 
                                befindet sich schon eine Konstante mit dem Namen Status. Sie soll nun anzeigen wer als n√§chstes dran ist. Dazu recyclen wir den Bedingungsoperator von oben und verketten ihn mit dem String 
                                "Next Player: " sodass die fertige Methode anschlie√üend so aussieht:
                            </p>
                            <pre>
                                <code class="JavaScript">
    render() {
        const status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');

        return (
            &lt;div>
            &lt;div className="status">{status}&lt;/div>
            &lt;div className="board-row">
                {this.renderSquare(0)}
                {this.renderSquare(1)}
                {this.renderSquare(2)}
            &lt;/div>
            &lt;div className="board-row">
                {this.renderSquare(3)}
                {this.renderSquare(4)}
                {this.renderSquare(5)}
            &lt;/div>
            &lt;div className="board-row">
                {this.renderSquare(6)}
                {this.renderSquare(7)}
                {this.renderSquare(8)}
            &lt;/div>
            &lt;/div>
        );
    }
                                </code>
                            </pre>
                            <p>
                                Jetzt k√∂nnen wir doch mal testen, ob bis jetzt alles funktioniert.
                            </p>
                            <video controls="controls">
                                <source src="vertiefungsThema/takingTurnsklappt.mp4" type="video/mp4">
                                Ihr Browser unterst√ºtzt den HTML Video Tag nicht.
                            </video>
                            <p>
                                Das sieht doch gut aus. Nun fehlt f√ºr einen wirklichen Spieldurchlauf nur noch eine Sache: Wir m√ºssen den Gewinner feststellen.
                            </p>
                            <h3>Den Gewinner feststellen</h3>
                            <p>
                                Dazu erstellen wir eine neue "Hilfsfunktion" am Ende unserer JavaScriptt Datei mit dem Namen calculateWinner. Diese beinhaltet ein Array, dass wiederrum alle m√∂glichen Linien zum Gewinnen enth√§lt. 
                                Hier sind das 8 - 3 horizontale, 3 vertikale und 2 diagonale. Wir pr√ºfen anschlie√üend mit Hilfe einer for Schleife alle 8 m√∂glichen Linien durch und "schauen" ob es dort nur Symbole eines Typs 
                                gibt bzw. ob es dort √ºberhaupt ein Symbol gibt (das machen wir widerrum mit einer if Verzweigung). Diese gibt, falls eine der M√∂glichkeiten passt, das Symbol des Gewinners zur√ºck.
                            </p>
                            <p>
                                In Code sieht das folgenderma√üen aus:
                            </p>
                            <pre>
                                <code class="JavaScript">
    function calculateWinner(squares) {
        const lines = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6],
        ];
        for (let i = 0; i &lt; lines.length; i++) {
            // hier weisen wir die L√∂sungsm√∂glichkeit einer lokalen Konstante innerhalb der Schleife zu
            const [a, b, c] = lines[i];
            // Wenn Square a nicht null ist und Square a = Square b und Square a = Square c ist, dann sind sie alle gleich und nicht null
            if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
            // Das Symbol des Gewinners zur√ºckgeben
            return squares[a];
            }
        }
        // Noch keiner hat gewonnen
        return null;
        }
                                </code>
                            </pre>
                            <p>
                                Wir haben nun die M√∂glichkeit einen Gewinner zu bestimmen. Wir m√ºssen sie nur noch einbauen. Das tun wir indem wir in der render Methode des Boards den "aktuellen Gewinner" errechnen lassen 
                                und eine if Abfrage einbauen, welche das Ergebnis dieser "Rechnung" auswertet.
                            </p>
                            <pre>
                                <code class="JavaScript">
    render() {
        const winner = calculateWinner(this.state.squares);
        let status;
        if (winner) {
            status = 'Winner: ' + winner;
        } else {
            status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');
        }
    // ...
                                </code>
                            </pre>
                            <p>
                                <b>Anbei:</b> Ich bin mir gerade nicht mehr ganz sicher, ob wir das innerhalb dieser Vorlesung mal angesprochen haben. Zumindest finde im Skript gerade nichts dazu, aber der Grund warum ich hier einfach 
                                if (winner) schreiben kann ist, dass in JavaScript alle Variablen mit dem Wert null (oder leere Strings) als false behandelt werden.
                            </p>
                            <p>
                                Bevor ich nun das finale Spiel zeige muss ich allerdings eine entscheidende Sache noch in Angriff nehmen. So kann ich zur Zeit noch Felder meines Gegners einfach √ºberschreiben und wenn der Gewinner 
                                feststeht einfach weiterspielen. Um das zu √§ndern m√ºssen wir die handleClick Methode noch einmal √ºberarbeiten. Sie soll Klicks nun ignorieren, wenn schon jemand gewonnen hat oder das Feld "schon nicht mehr 
                                null ist".
                            </p>
                            <p>
                                Auch das l√§sst sich mit einer kleinen if Abfrage bewerkstelligen.
                            </p>
                            <pre>
                                <code class="JavaScript">
    handleClick(i) {
        const squares = this.state.squares.slice();
        // Hier ist unsere if Abfrage
        if (calculateWinner(squares) || squares[i]) {
            return;
        }
        squares[i] = this.state.xIsNext ? 'X' : 'O';
        this.setState({
            squares: squares,
            xIsNext: !this.state.xIsNext,
        });
    }
                                </code>
                            </pre>
                            <p>
                            <h3>Wir haben es geschafft! Das grundlegende Spiel ist fertig!</h3>
                            <p>
                                Und so sieht es nun aus:
                            </p>
                            </p>
                            <video controls="controls">
                                <source src="vertiefungsThema/fertigesSpiel.mp4" type="video/mp4">
                                Ihr Browser unterst√ºtzt den HTML Video Tag nicht.
                            </video>
                            <h3>Bonusfunktion</h3>
                            <p>
                                Die Grundfunktionlait√§t des Spiels l√§uft nun also. Zeit um sich auszuruhen oder? Naja fast. Zur Zeit muss mann, wenn man ein neues Spiel beginnen will die Seite neu laden. Au√üerdem kann 
                                man sich die vorangegangenen Z√ºge nicht anschauen bzw. kann man dahin nicht zur√ºckspringen.
                            </p>
                            <p>
                                Eben das wollen wir jetzt m√∂glich machen. Dazu m√ºssen wir unseren Code aber noch einmal sehr stark umstrukturieren. Also fangen wir lieber mal an...
                            </p>
                            <h4>Vorherige Schritte zwischenspeichern</h4>
                            <p>
                                Wie bereits oben kurz angeschnitten haben wir unser Squares Array nie direkt manipuliert. Das bietet uns jetzt den Vorteil, dass wir alle vorangegangenen Spielfelder in einem weiteren Array mit 
                                dem Namen history ablegen k√∂nnen.
                            </p>
                            <h4>Das mit dem State (schon wieder)</h4>
                            <p>
                                Das mit der History ist sch√∂n und gut, nur wollen wir diese (wenn m√∂glich) nicht innerhalb unseres Spielbrettes, sondern √ºber die Game Komponente ausgeben. Dabei haben wir allerdings ein Problem. 
                                Der Status des Spielbrettes ist im Board gespeichert. Wir brauchen also mal wieder ein wenig "Refactoring", wie es im Englischen so sch√∂n hei√üt.
                            </p>
                            <p>
                                First things first, unsere Game Komponente braucht ein history Array (und dazu nat√ºrlich dann auch einen eigenen Konstruktor).
                            </p>
                            <pre>
                                <code class="JavaScript">
    class Game extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
            history: [{
                squares: Array(9).fill(null),
            }],
            xIsNext: true,
        };
    }

    //...
                                </code>
                            </pre>
                            <p>
                                Wie man sehen kann f√ºllen wir dieses schon einmal mit einem ersten "Backup" unseres State Objekts. Deswegen sind zu den eckigen Klammern zus√§tzlich noch runde Klammern hier dabei. Es handelt sich um ein 
                                Array, welches ein JSON Objekt beinhaltet. Auch beinhaltet der Status hier schon unsere xIsNext Variable, welche wir schon aus der Board Komponente kennen und auch schon einmal signalisiert wo der Weg hingehen wird.
                            </p>
                            <p>
                                Wir verlagern nun einen Gro√üteil der Logik aus der Board Komponente in die Game Komponente. Dazu ...
                            </p>
                            <ol>
                                <li>... l√∂schen wir den Konstruktor des Boards, ...</li>
                                <li>... ersetzen this.state.squares[i] mit this.props.square[i] in der renderSquare Methode des Boards und ...</li>
                                <li>... ersetzen dort auch this.handelClick(i) durch this.props.onClick(i).</li>
                            </ol>
                            <p>
                                Wir verweisen so also nicht mehr auf im Board vorhandene Eigenschaften, sonder auf √ºbergebene props.
                            </p>
                            <p>
                                Diese props m√ºssen nun aber auch erst mal existieren und so verschieben wir die handleClick Funktion erst einmal von der Board zur Game Klasse. W√ºrden wir die App nun versuchen zu √∂ffnen w√ºrden wir mit Fehlermeldungen 
                                bombadiert werden (habs probiert, sieht nicht sch√∂n aus üòÖ). Ist aber auch nur logisch, unsere alte handleClick Funktion sucht nach einem squares Array, dass es jetzt nat√ºrlich nicht mehr gibt. 
                                Wir m√ºssen sie also modifizierten um immer das aktuellste/letzte Element der history als aktuellen Status zu "verstehen".
                            </p>
                            <p>
                                Dazu holen wir uns das letzte Element des history Arrays als Konstante current und packen mit der slice Funktion eine Kopie in unsere lokale Variable squares, mit welcher handle Click arbeiten kann.
                            </p>
                            <p>
                                Abschlie√üend m√ºssen wir nur noch daf√ºr sorgen, dass der Status "richtig" neu gesetzt wird. Wir verwenden hier die concat Funktion und f√ºge unseren neuen Status an das urspr√ºngliche history Array an. 
                                Das Ergebnis setzen wir als neues history Array fest.
                            </p>
                            <pre>
                                <code class="JavaScript">
    handleClick(i) {
        // Unsere Aktuelle History
        const history = this.state.history;
        // Das letzte Element des Arrays
        const current = history[history.length - 1];
        // Wir legen eine Kopie des letzten Elementes an und nennen es squares
        const squares = current.squares.slice();
        if (calculateWinner(squares) || squares[i]) {
            return;
        }
        squares[i] = this.state.xIsNext ? 'X' : 'O';
        this.setState({
            // Anf√ºgen des neuen Status an die History
            history: history.concat([{
            squares: squares,
            }]),
            xIsNext: !this.state.xIsNext,
        });
    }
                                </code>
                            </pre>
                            <p>
                                Als letztes in unserer gro√üen "Funktionen Wanderschafft" wird nun auch das Anzeigen des Status ins Game hochgezogen und die √úbergabe der neu erstellten Funktionen an das Board geregelt.
                            </p>
                            <p>
                                All das machen wir (gro√üe √úberraschung) in der render Methode der Game Komponente. Dort implementieren wir eine √§hnliche Selektion des aktuellen Spielbrettes wie in der handleClick Methode. 
                                Die anschlie√üende Bestimmung, ob es einen Sieger gibt bleibt nahezu gleich.
                            </p>
                            <pre>
                                <code class="JavaScript">
    render() {
        const history = this.state.history;
        const current = history[history.length - 1];
        const winner = calculateWinner(current.squares);

        let status;
        if (winner) {
            status = 'Winner: ' + winner;
        } else {
            status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');
        }
    
        return (
            &lt;div className="game">
            &lt;div className="game-board">
                &lt;Board
                squares={current.squares}
                onClick={(i) => this.handleClick(i)}
                />
            &lt;/div>
            &lt;div className="game-info">
                &lt;div>{status}&lt;/div>
                &lt;ol>{/* TODO */}&lt;/ol>
            &lt;/div>
            &lt;/div>
        );
    }
                                </code>
                            </pre>
                            <p>
                                Wie man sehen kann, √ºbergeben wir nun auch das aktuelle Spielbrett und die handleClick Methode der Game Komponente an das Board.
                            </p>
                            <p>
                                Zum "Aufr√§umen" k√∂nnen wir abschlie√üend noch den Code zum Anzeigen des Status aus der render Methode des Boards entfernen. Dieser wird ja nun √ºber die render Methode des 
                                Games ausgegeben.
                            </p>
                            <h4>Die vergangenen Z√ºge auch anzeigen</h4>
                            <p>
                                Das Spiel funktioniert nun √§u√üerlich wieder wie vorher. Das ist zwar sch√∂n und gut, aber nicht unser Ziel. Wir speichern nun im Hintergrund jeden Zug in unserem history Array ab.
                                Der n√§chste Schritt ist es diese Z√ºge auch sichtbar zu machen.
                            </p>
                            <p>
                                Wir m√ºssen uns also eine Liste aller vorangegangenen Z√ºge ausgeben lassen und diese Klickbar gestalten. Dazu nutzen wir die map Methode auf unserem history Array.
                            </p>
                            <pre>
                                <code class="JavaScript">
    const moves = history.map((step, move) => {
        const desc = move ?
            'Go to move #' + move :
            'Go to game start';
        return (
            &lt;li>
                &lt;button onClick={() => this.jumpTo(move)}>{desc}&lt;/button>
            &lt;/li>
        );
    });
                                </code>
                            </pre>
                            <p>
                                Die Erstellung der Listen Elemente ist eigentlich ziemlich selbsterkl√§rend. Die Verwendung der Map Methode allerdings erschloss sich mir anfangs nicht. Ein kurzer Ausflug zu Google sp√§ter 
                                hat die Verwirrung jedoch beheben k√∂nnen. Und zwar wird die Map Methode auf Arrays aufgerufen und kann diese beliebig ver√§ndern um so ein neues Array auszugeben. Dazu akzeptiert sie, wie bei uns, Funktionen. 
                                In diesem Fall unsere Arrow Funktion, die aus jedem Element ein Listen Element erstellt. Als √úbergabe Parameter an diese Funktion werden au√üerdem "currentValue", "index" und "arr" (das Array auf dem wir arbeiten) angeboten. 
                                Wir nutzen davon zwei. Wir √ºbergeben den Inhalt des Elementes (also unsere Squares) als step und den Index des Schrittes als move.
                            </p>
                            <p>
                                Nachdem ich mir das bewusst gemacht hatte, sah das pl√∂tzlich alles auch nicht mehr so kompliziert aus. Wir f√ºgen nun noch {moves} in die geordnete Liste in den return der render Methode ein um unsere Liste auch f√ºr den Nutzer 
                                sichtbar zu machen.
                            </p>
                            <pre>
                                <code class="JavaScript">
    return (
      &lt;div className="game">
        &lt;div className="game-board">
            &lt;Board
                squares={current.squares}
                onClick={(i) => this.handleClick(i)}
            />
        &lt;/div>
        &lt;div className="game-info">
            &lt;div>{status}&lt;/div>
            &lt;ol>{moves}&lt;/ol>
        &lt;/div>
      &lt;/div>
    );
                                </code>
                            </pre>
                            <p>
                                Wie vielleicht dem ein oder anderen aufegfallen ist, rufen wir mit den Buttons die Funktion jumpTo auf. Da wir diese Funktion in der Game Komponente noch nicht haben sollte das unser n√§chster Schritt sein oder?<br>
                                Und wie immer wenn ich so frage ist die Antwort nein.<br>
                                Wir m√ºssen uns erst einem anderen "Problem" annehmen.
                            </p>
                            <img src="vertiefungsThema/warnungKeyprop.PNG">
                            <p>
                                Listenelemente innerhalb von React ben√∂tigen immer einen eindeutigen Schl√ºssel. Das hat vor allem den Grund, dass React f√ºr uns automatisch das aktualisieren von Komponenten √ºbernimmt (deswegen mussten wir bis jetzt auch keine Update Funktionen 
                                oder √§hnliches schreiben). Damit es aber √Ñnderungen effizient und richtig erkennen kann braucht es eindeutige Schl√ºssel. Hierzu gibt es zwar auch Plugins f√ºr Ract (beispielsweise UUID) aber in unserem Beispiel machen wir uns das ganze etwas einfacher. 
                                Wir weisen dem Listenelement einfach den Array Index als Schl√ºssel zu.
                            </p>
                            <pre>
                                <code class="JavaScript">
    const moves = history.map((step, move) => {
        const desc = move ?
            'Go to move #' + move :
            'Go to game start';
        return (
            // Hier kommt unser Schl√ºssel dazu
            &lt;li key={move}>
                &lt;button onClick={() => this.jumpTo(move)}>{desc}&lt;/button>
            &lt;/li>
        );
    });
                                </code>
                            </pre>
                            <p>
                                Jetzt da das aus dem Weg ist k√∂nnen wir das Springen zu verschiedenen Schritten implementieren.
                            </p>
                            <p>
                                Dazu brauchen wir folgendes:
                            </p>
                            <ol>
                                <li>Wir m√ºssen wissen, bei welchem Schritt wir gerade sind, ...</li>
                                <li>... wir brauchen unsere jumpTo Methode, ...</li>
                                <li>... ein Weiterspielen "in der Vergangenheit" l√∂scht die alte Zukunft und ...</li>
                                <li>... die render Methode des Game muss uns immer den Status des Bretts beim aktuellen Schritt anzeigen.</li>
                            </ol>
                            <p>
                                Wir fangen also mit 1. an. Dazu f√ºgen wir dem state im Konstruktor der Game Komponente die Varible stepNumber hinzu und setzen sie dort auf 0 (wir haben ja am Anfang noch keinen Zug gemacht).<br>
                                Nummer 1 - check.
                            </p>
                            <p>
                                Danach erstellen wir die jumpTo Methode. Diese akzeptiert den Parameter step und setzt den Status des Spiels auf den aktuellen Step. Au√üerdem nutzen wir Modulo 2 um zu √ºberpr√ºfen, ob der Schritt zu dem wir 
                                springen wollen gerade ist. Wenn ja, ergibt die Auswertung true. Diesen Wert schreiben wir dann in xIsNext. Das macht deshalb Sinn, da X anf√§ngt und somit immer bei geraden Schritten dran ist.
                            </p>
                            <pre>
                                <code class="JavaScript">
    jumpTo(step) {
        this.setState({
            stepNumber: step,
            xIsNext: (step % 2) === 0,
        });
    }
                                </code>
                            </pre>
                            <p>
                                Nummer 2 - check.
                            </p>
                            <p>
                                Jetzt wollen wir, dass ein Klick innerhalb der Vergangenheit die alte Zukunft l√∂scht. Wir verlieren also alle nach dem ausgew√§hlten Schritt gemachte Z√ºge, wenn wir von dort aus auf die Squares klicken. 
                                Das geht relativ einfach indem wir uns noch einmal an die handleClick Methode setzen.
                            </p>
                            <p>
                                Diese greift sich in der aktuellen Version einfach das history Array und w√§hlt das letzte Element als aktuelles aus. Was wir nun machen m√ºssen ist daf√ºr zu sorgen, dass das History Array nur bis zum aktuell 
                                betrachtetem Schritt ausgew√§hlt und in die Konstante history geschrieben wird.
                            </p>
                            <p>
                                Das erreichen wir mit der slice Methode. Diese akzeptiert in einer ihrer Abwandlungen zwei Parameter - den Start und End Index. Der Befehl sieht also anschlie√üend so aus:
                            </p>
                            <pre>
                                <code class="JavaScript">
    const history = this.state.history.slice(0, this.state.stepNumber + 1);
                                </code>
                            </pre>
                            <p>
                                Nat√ºrlich m√ºssen wir den neuen Schritt am Ende der handleClick Methode auch wieder an den Status zur√ºckgeben.
                            </p>
                            <pre>
                                <code class="JavaScript">
    this.setState({
        history: history.concat([{
            squares: squares
        }]),
        // Wir nutzen hier die L√§nge des history Arrays
        stepNumber: history.length,
        xIsNext: !this.state.xIsNext,
        });
                                </code>
                            </pre>
                            <p>
                                Nummer 3 - check.
                            </p>
                            <p>
                                Die Hintergrundarbeiten sind nun abgeschlossen. Jetzt muss uns das Brett aber auch den aktuell ausgew√§hlten Schritt anzeigen. Das passiert in der render Methode der Game Komponente wenn 
                                wir das aktuelle Spielbrett ausw√§hlen. Wir tauschen hier history.length-1 gegen this.state.stepNumber aus.
                            </p>
                            <pre>
                                <code class="JavaScript">
    render() {
        const history = this.state.history;
        // Aktuellen Schritt anzeigen
        const current = history[this.state.stepNumber];
        const winner = calculateWinner(current.squares);
    // ...
                                </code>
                            </pre>
                            <p>
                                Nummer 4 - check.
                            </p>
                            <h4>Die Bonusfunktion ist fertig</h4>
                            <p>
                                Nun ist das "Zeitreisen" fertig implementiert und wir k√∂nnen es testen.
                            </p>
                            <video controls="controls">
                                <source src="vertiefungsThema/komplettFertigShowcase.mp4" type="video/mp4">
                                Ihr Browser unterst√ºtzt den HTML Video Tag nicht.
                            </video>
                            <h2>Fazit</h2>
                            <p>
                                Alles in allem ist React eine vielseitige wenn auch am Anfang etwas verwirrende Bibliothek. Eines ist klar. Es ist nich so einfach einzubauen wie JQuery. Man ben√∂tigt einen Node.js Server 
                                und muss ein Projekt erstellen. Wenn man sich aber einmal dort hindurch gek√§mpft hat, ist es relativ verst√§ndlich und l√§sst sich √§hnlich zu JQurey noch mit weiteren Modulen (in JQuery Plugins) erg√§nzen. 
                                Ich habe allerding bis jetzt erst einen ungef√§hren Eindruck von dem erhalten, was man mit React umsetzen kann (so zumindest mein Gef√ºhl). Nur gut, dass ich im neuen Jahr noch Resturlaub abbauen muss. 
                                Dann kann man sich das noch einmal genauer anschauen üòÖ.
                            </p>
                            <p><b>PS:</b> Den fertigen Quellcode findet man <a href="https://codepen.io/gaearon/pen/gWWZgR" target="_blank">hier</a>. Dies ist der vollst√§ndige Code aus dem Tutorial, aber da ich dieses befolgt habe ist der Code bis auf 
                            wenige stilistische Feinheiten (z.B. Einr√ºckungen) identisch.</p>
                    </main>
                </section>
            </main>
            <footer>
                <p>Diese Seite wurde im Kontext eines Kurses an der <a href="https://dhbw-mannheim.de" target="_blank"><img src="../img/dhbw_logo.svg" alt="DHBW Mannheim" height="20px"></a> zu 99% selbst erstellt.</p>
                <p>&copy2020-2021 Patrick Pfurtscheller</p>
            </footer>
        </div>
    </body>
</html>